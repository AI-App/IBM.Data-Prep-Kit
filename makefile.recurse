# Provide some common rules and functions for our tree of Makefiles
#################################################################################################################
#
# This provides common support for all Makefiles in the project. 
# It enables the processing of  a common set of rules on all sub-projects underneath this directory.  
# Currently, the common/standardized set of rules are as follows and supported by makefile.include
#
# clean: 
# build:
# publish:
#
# When finally getting to a makefile that requires a rule implementation, for example to publish the build,
# that makefile should override/implement the rule to meet its needs.  Such a rule may continue to recurse
# using "$(MAKE) <rule>-recurse", for example "$(MAKE) publish-recurse". 
#
# Each rule is called recursively on sub-directories and if a similar inclusion is done in the sub-Makefiles,
# the rules will be applied/executed recursively in their sub-directories.
#
#################################################################################################################

# Rules with actual dependencies executed as commands
.PHONY: __recurse __build-recurse __clean-recurse __publish-recurse 

# By default recurse into all sub-directories that do not begin with .
SUB_MAKE_DIRS=$(shell echo */) 

__build-recurse:
	$(MAKE) RULE=build __recurse

__publish-recurse:
	$(MAKE) RULE=publish __recurse

__clean-recurse:
	$(MAKE) RULE=clean __recurse

__recurse: 
	@if [ ! -z "$(SUB_MAKE_DIRS)" ]; then	\
	    for i in $(SUB_MAKE_DIRS); do	\
		if [ -e $$i/Makefile ]; then	\
		    echo Using recursive $(RULE) rule in $(shell pwd);	\
		    (cd $$i; $(MAKE) $(RULE));	\
		fi;				\
	    done;				\
	fi

# This rule allows sub-directories to override/define rule X for each X-recurse rule above.
# See https://stackoverflow.com/questions/11958626/make-file-warning-overriding-commands-for-target
%: __%-recurse
	@echo 1 > /dev/null	



